{"ast":null,"code":"import DEFAULT_TOKEN_LIST from '@excswap/default-token-list';\nimport { ChainId, Token } from 'sb1swap-sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport sortByListPriority from './listSort';\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  constructor(tokenInfo, tags) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);\n    this.tokenInfo = void 0;\n    this.tags = void 0;\n    this.tokenInfo = tokenInfo;\n    this.tags = tags;\n  }\n\n  get logoURI() {\n    return this.tokenInfo.logoURI;\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.KOVAN]: {},\n  [ChainId.RINKEBY]: {},\n  [ChainId.ROPSTEN]: {},\n  [ChainId.GÖRLI]: {},\n  [ChainId.MAINNET]: {},\n  [ChainId.BSC]: {},\n  [ChainId.TBSC]: {},\n  [ChainId.MATIC]: {}\n};\nconst listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToTokenMap(list) {\n  const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);\n  if (result) return result;\n  const map = list.tokens.reduce((tokenMap, tokenInfo) => {\n    var _tokenInfo$tags$map$f, _tokenInfo$tags, _tokenInfo$tags$map;\n\n    const tags = (_tokenInfo$tags$map$f = (_tokenInfo$tags = tokenInfo.tags) === null || _tokenInfo$tags === void 0 ? void 0 : (_tokenInfo$tags$map = _tokenInfo$tags.map(tagId => {\n      var _list$tags;\n\n      if (!((_list$tags = list.tags) === null || _list$tags === void 0 ? void 0 : _list$tags[tagId])) return undefined;\n      return { ...list.tags[tagId],\n        id: tagId\n      };\n    })) === null || _tokenInfo$tags$map === void 0 ? void 0 : _tokenInfo$tags$map.filter(x => Boolean(x))) !== null && _tokenInfo$tags$map$f !== void 0 ? _tokenInfo$tags$map$f : [];\n    const token = new WrappedTokenInfo(tokenInfo, tags);\n    if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.');\n    return { ...tokenMap,\n      [token.chainId]: { ...tokenMap[token.chainId],\n        [token.address]: {\n          token,\n          list: list\n        }\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);\n  return map;\n}\nexport function useAllLists() {\n  return useSelector(state => state.lists.byUrl);\n}\n\nfunction combineMaps(map1, map2) {\n  return {\n    1: { ...map1[1],\n      ...map2[1]\n    },\n    3: { ...map1[3],\n      ...map2[3]\n    },\n    4: { ...map1[4],\n      ...map2[4]\n    },\n    5: { ...map1[5],\n      ...map2[5]\n    },\n    42: { ...map1[42],\n      ...map2[42]\n    },\n    56: { ...map1[56],\n      ...map2[56]\n    },\n    97: { ...map1[97],\n      ...map2[97]\n    },\n    80001: { ...map1[80001],\n      ...map2[80001]\n    }\n  };\n} // merge tokens contained within lists from urls\n\n\nfunction useCombinedTokenMapFromUrls(urls) {\n  const lists = useAllLists();\n  return useMemo(() => {\n    if (!urls) return EMPTY_LIST;\n    return urls.slice() // sort by priority so top priority goes last\n    .sort(sortByListPriority).reduce((allTokens, currentUrl) => {\n      var _lists$currentUrl;\n\n      const current = (_lists$currentUrl = lists[currentUrl]) === null || _lists$currentUrl === void 0 ? void 0 : _lists$currentUrl.current;\n      if (!current) return allTokens;\n\n      try {\n        const newTokens = Object.assign(listToTokenMap(current));\n        return combineMaps(allTokens, newTokens);\n      } catch (error) {\n        console.error('Could not show token list due to error', error);\n        return allTokens;\n      }\n    }, EMPTY_LIST);\n  }, [lists, urls]);\n} // filter out unsupported lists\n\n\nexport function useActiveListUrls() {\n  return useSelector(state => state.lists.activeListUrls);\n}\nexport function useInactiveListUrls() {\n  const lists = useAllLists();\n  const allActiveListUrls = useActiveListUrls();\n  return Object.keys(lists).filter(url => !(allActiveListUrls === null || allActiveListUrls === void 0 ? void 0 : allActiveListUrls.includes(url)));\n} // get all the tokens from active lists, combine with local default tokens\n\nexport function useCombinedActiveList() {\n  const activeListUrls = useActiveListUrls();\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls);\n  const defaultTokenMap = listToTokenMap(DEFAULT_TOKEN_LIST);\n  return combineMaps(activeTokens, defaultTokenMap);\n} // all tokens from inactive lists\n\nexport function useCombinedInactiveList() {\n  const allInactiveListUrls = useInactiveListUrls();\n  return useCombinedTokenMapFromUrls(allInactiveListUrls);\n} // used to hide warnings on import for default tokens\n\nexport function useDefaultTokenList() {\n  return listToTokenMap(DEFAULT_TOKEN_LIST);\n} // list of tokens not supported on interface, used to show warnings and prevent swaps and adds\n// get any loaded unsupported tokens\n// format into one token address map\n\nexport function useIsListActive(url) {\n  const activeListUrls = useActiveListUrls();\n  return Boolean(activeListUrls === null || activeListUrls === void 0 ? void 0 : activeListUrls.includes(url));\n}","map":{"version":3,"sources":["D:/solidityproj/esccoinswap/interface-i18n1.3/src/state/lists/hooks.ts"],"names":["DEFAULT_TOKEN_LIST","ChainId","Token","useMemo","useSelector","sortByListPriority","WrappedTokenInfo","constructor","tokenInfo","tags","chainId","address","decimals","symbol","name","logoURI","EMPTY_LIST","KOVAN","RINKEBY","ROPSTEN","GÖRLI","MAINNET","BSC","TBSC","MATIC","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tagId","undefined","id","filter","x","Boolean","token","Error","set","useAllLists","state","lists","byUrl","combineMaps","map1","map2","useCombinedTokenMapFromUrls","urls","slice","sort","allTokens","currentUrl","current","newTokens","Object","assign","error","console","useActiveListUrls","activeListUrls","useInactiveListUrls","allActiveListUrls","keys","url","includes","useCombinedActiveList","activeTokens","defaultTokenMap","useCombinedInactiveList","allInactiveListUrls","useDefaultTokenList","useIsListActive"],"mappings":"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","sourcesContent":["\nimport DEFAULT_TOKEN_LIST from '@excswap/default-token-list'\nimport { ChainId, Token } from 'sb1swap-sdk'\nimport { Tags, TokenInfo, TokenList } from '@excswap/token-lists'\nimport { useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { AppState } from '../index'\nimport sortByListPriority from './listSort'\n\ntype TagDetails = Tags[keyof Tags]\nexport interface TagInfo extends TagDetails {\n  id: string\n}\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  public readonly tokenInfo: TokenInfo\n  public readonly tags: TagInfo[]\n  constructor(tokenInfo: TokenInfo, tags: TagInfo[]) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name)\n    this.tokenInfo = tokenInfo\n    this.tags = tags\n  }\n  public get logoURI(): string | undefined {\n    return this.tokenInfo.logoURI\n  }\n}\n\nexport type TokenAddressMap = Readonly<\n  { [chainId in ChainId]: Readonly<{ [tokenAddress: string]: { token: WrappedTokenInfo; list: TokenList } }> }\n>\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: TokenAddressMap = {\n  [ChainId.KOVAN]: {},\n  [ChainId.RINKEBY]: {},\n  [ChainId.ROPSTEN]: {},\n  [ChainId.GÖRLI]: {},\n  [ChainId.MAINNET]: {},\n  [ChainId.BSC]: {},\n  [ChainId.TBSC]: {},\n  [ChainId.MATIC]: {}\n}\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  typeof WeakMap !== 'undefined' ? new WeakMap<TokenList, TokenAddressMap>() : null\n\nexport function listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list)\n  if (result) return result\n\n  const map = list.tokens.reduce<TokenAddressMap>(\n    (tokenMap, tokenInfo) => {\n      const tags: TagInfo[] =\n        tokenInfo.tags\n          ?.map(tagId => {\n            if (!list.tags?.[tagId]) return undefined\n            return { ...list.tags[tagId], id: tagId }\n          })\n          ?.filter((x): x is TagInfo => Boolean(x)) ?? []\n      const token = new WrappedTokenInfo(tokenInfo, tags)\n      if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.')\n      return {\n        ...tokenMap,\n        [token.chainId]: {\n          ...tokenMap[token.chainId],\n          [token.address]: {\n            token,\n            list: list\n          }\n        }\n      }\n    },\n    { ...EMPTY_LIST }\n  )\n  listCache?.set(list, map)\n  return map\n}\n\nexport function useAllLists(): {\n  readonly [url: string]: {\n    readonly current: TokenList | null\n    readonly pendingUpdate: TokenList | null\n    readonly loadingRequestId: string | null\n    readonly error: string | null\n  }\n} {\n  return useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n}\n\nfunction combineMaps(map1: TokenAddressMap, map2: TokenAddressMap): TokenAddressMap {\n  return {\n    1: { ...map1[1], ...map2[1] },\n    3: { ...map1[3], ...map2[3] },\n    4: { ...map1[4], ...map2[4] },\n    5: { ...map1[5], ...map2[5] },\n    42: { ...map1[42], ...map2[42] },\n    56: { ...map1[56], ...map2[56] },\n    97: { ...map1[97], ...map2[97] },\n    80001: { ...map1[80001], ...map2[80001] }\n  }\n}\n\n// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls: string[] | undefined): TokenAddressMap {\n  const lists = useAllLists()\n\n  return useMemo(() => {\n    if (!urls) return EMPTY_LIST\n\n    return (\n      urls\n        .slice()\n        // sort by priority so top priority goes last\n        .sort(sortByListPriority)\n        .reduce((allTokens, currentUrl) => {\n          const current = lists[currentUrl]?.current\n          if (!current) return allTokens\n          try {\n            const newTokens = Object.assign(listToTokenMap(current))\n            return combineMaps(allTokens, newTokens)\n          } catch (error) {\n            console.error('Could not show token list due to error', error)\n            return allTokens\n          }\n        }, EMPTY_LIST)\n    )\n  }, [lists, urls])\n}\n\n// filter out unsupported lists\nexport function useActiveListUrls(): string[] | undefined {\n  return useSelector<AppState, AppState['lists']['activeListUrls']>(state => state.lists.activeListUrls)\n}\n\nexport function useInactiveListUrls(): string[] {\n  const lists = useAllLists()\n  const allActiveListUrls = useActiveListUrls()\n  return Object.keys(lists).filter(url => !allActiveListUrls?.includes(url))\n}\n\n// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(): TokenAddressMap {\n  const activeListUrls = useActiveListUrls()\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls)\n  const defaultTokenMap = listToTokenMap(DEFAULT_TOKEN_LIST)\n  return combineMaps(activeTokens, defaultTokenMap)\n}\n\n// all tokens from inactive lists\nexport function useCombinedInactiveList(): TokenAddressMap {\n  const allInactiveListUrls: string[] = useInactiveListUrls()\n  return useCombinedTokenMapFromUrls(allInactiveListUrls)\n}\n\n// used to hide warnings on import for default tokens\nexport function useDefaultTokenList(): TokenAddressMap {\n  return listToTokenMap(DEFAULT_TOKEN_LIST)\n}\n\n// list of tokens not supported on interface, used to show warnings and prevent swaps and adds\n\n\n  // get any loaded unsupported tokens\n\n  // format into one token address map\n\n\nexport function useIsListActive(url: string): boolean {\n  const activeListUrls = useActiveListUrls()\n  return Boolean(activeListUrls?.includes(url))\n}\n"]},"metadata":{},"sourceType":"module"}